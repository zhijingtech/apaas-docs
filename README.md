# ORY 全家桶一瞥

随着互联网应用的复杂性不断增加，身份管理和访问控制成为开发者必须面对的挑战。对于一个现代化的应用来说，如何高效地管理用户身份、确保安全的访问控制是至关重要的。在这篇文章中，我们将一瞥 ORY 全家桶，探索其在身份即服务（IDaaS）领域中提供的解决方案，涵盖了登录认证、用户 ID 管理、权限和访问控制、API 访问和 OAuth2 等大部分关联知识。

## ORY 全家桶简介

ORY 全家桶是一个开源的身份管理解决方案集合，旨在为开发者提供一套完整的工具来解决身份认证与授权的问题。ORY 全家桶包括以下几个核心组件：

1. ORY Kratos：一个用户管理系统，专注于自定义用户登录、注册和身份管理。
2. ORY Hydra：一个 OAuth2 和 OpenID Connect 服务器，帮助应用实现安全的用户登录和 API 访问。
3. ORY Keto：一个访问控制引擎，基于开源的 Google Zanzibar 模型，提供灵活的权限管理。
4. ORY Oathkeeper：一个身份和访问代理，用于保护 API 和应用的入口。

![ORY全家桶](https://www.ory.sh/docs/assets/images/1-42e65393379b7f7ddc3f9a05474f27ac.png)

### ORY Kratos

Kratos 的领域模型围绕用户身份管理展开，包括用户身份、会话、身份验证器、恢复策略等。

- 用户身份 ：用户的基本信息和认证数据。
- 会话 ：用户的登录状态。
- 身份验证器 ：支持多种认证方式，如密码、MFA 等。
- 恢复策略 ：账户恢复和密码重置流程。

核心逻辑

- 身份管理 ：支持用户注册、登录、注销和信息更新。
- 自定义认证流程 ：允许开发者定义复杂的身份验证和注册逻辑。

亮点设计

- 模块化架构 ：各个功能模块可独立配置和扩展。
- 多协议支持 ：支持多种身份验证协议，适应不同的安全需求。

### ORY Hydra

ORY Hydra 专注于 OAuth2 和 OpenID Connect 协议的实现。其领域模型包括客户端、授权请求、访问令牌、刷新令牌等实体。

- 客户端 ：代表可以请求访问令牌的应用程序。
- 授权请求 ：用户同意或拒绝访问请求的流程。
- 令牌 ：用于访问受保护资源的凭证。

核心逻辑

- OAuth2 授权流程 ：支持授权码、隐式、客户端凭证和资源所有者密码凭证四种授权模式。
- OpenID Connect：扩展 OAuth2，提供用户身份验证功能。

亮点设计

- 可扩展性 ：Hydra 允许开发者通过插件机制扩展其功能。
- 高可用性 ：设计为无状态服务，便于水平扩展。
- 安全性 ：实现了 OAuth2 和 OIDC 的所有安全最佳实践。

### ORY Keto

Keto 基于 Google Zanzibar 模型进行权限管理，核心模型包括关系、角色、权限、资源等。

- 关系 ：定义用户、角色、资源之间的关联。
- 角色 ：用户可以被赋予不同的角色，每个角色具有特定的权限。
- 资源 ：被保护的对象或数据。

核心逻辑

- 关系查询 ：高效地评估用户是否有权访问某个资源。
- 权限继承 ：支持复杂的权限继承和角色间的层级关系。

亮点设计

- 灵活的权限模型 ：支持动态的权限规则，适应复杂的业务逻辑。
- 高性能 ：优化的查询引擎，能够处理大规模的权限数据。

### ORY Oathkeeper

Oathkeeper 作为一个身份和访问代理，其模型包括规则、身份提供者、认证器、授权者等。

- 规则 ：定义请求的处理逻辑，包括身份验证和授权。
- 身份提供者 ：外部系统，提供身份验证服务。
- 认证器 ：用于验证请求者身份的组件。
- 授权者 ：用于决定请求是否被允许的组件。

核心逻辑

- 请求代理 ：拦截和处理所有进入的请求，根据规则进行身份验证和授权。
- 策略执行 ：支持多种策略执行模式，灵活配置请求处理逻辑。

亮点设计

- 可插拔架构 ：认证和授权模块都可以通过插件进行扩展。
- 集中管理 ：集中化管理 API 的安全策略，简化安全配置。

## ORY 全家桶部署

部署 ORY 全家桶并不复杂，下面是一个简单的指南，帮助你在本地环境中快速启动：

### 环境准备

- Docker：确保你的系统上已经安装了 Docker。
- Docker Compose：用于管理多个 Docker 容器的工具。

### 部署步骤

我们直接提供了一个 ORY 全家桶部署的 docker-compose.yml 文件，可执行如下命令下载后直接启动：

```shell
git clone https://github.com/zhijingtech/ory-all-test.git
cd ory-all-test
docker-compose up
```

这将启动 Hydra、Kratos 和 Keto 服务。通过 docker desktop 检查各个服务是否正常运行，名称中带 migrate 的容器处于退出状态是正常。

**注意**：启动过程中一定会遇到 migrate 容器报错，原因是各个组件的 migrate 工具会重复创建 network 表，导致冲突，此时可以把报错的迁移 version 插入 schema_migration 即可。比如遇到如下报错时：

```shell
2024-11-26 18:52:44 ERROR: relation "networks" already exists (SQLSTATE 42P07)
2024-11-26 18:52:44 error executing migrations/20150101000001000000_networks.postgres.up.sql, sql: -- Migration generated by the command below; DO NOT EDIT.
```

记得插入一条 schema_migration 记录，vesion 的值取值日志：

```shell
-- hydra-migrate 报错
INSERT INTO schema_migration ("version", version_self) VALUES('20150101000001000000', 0);
-- Keto-migrate 报错
INSERT INTO schema_migration ("version", version_self) VALUES('20150100000001000000', 0);
```

如果没有容器在不停的重启，基本上代表部署成功了。

### 场景测试

所有的测试请求都通过 Oathkeeper Proxy 转发其他模块，转发规则详见 Oathkeeper 的配置文件 rules.json，后续不再特别说明。如果将 ORY 应用于生产，通过 Oathkeeper 或者其他网关构建零信任系统，禁止业务接口直接暴露外网，是一种比较安全的设计。

Kratos 允许用户自己配置注册、登录、用户设置、账号恢复等流程，流程又分成了 browser（适用于浏览器端，有重定向和 Cookies 逻辑）和 api（适用于移动端）两种，使用的安全措施会有所不同但是返回的模型一致。详见：https://www.ory.sh/docs/kratos/self-service。

#### 用户注册

1. 注册用户

这里为了测试方便使用 api 类型的注册流程。

```shell
flowId=$(curl -s -X GET \
    -H "Accept: application/json" \
    http://127.0.0.1:4555/self-service/registration/api | jq -r '.id')
curl -s -X GET \
    -H "Accept: application/json" \
    "http://127.0.0.1:4555/self-service/registration/flows?id=$flowId" | jq
```

返回了用户注册的流程和表单定义，可以看到注册需要提供邮箱、姓名、密码等信息。此时 selfservice_registration_flows 表中会生成一条注册流程，有效期是 10 分钟，过期后需要重新获取流程。因为还没有提交表单，所以没有生成用户。

接下来我们提交用户注册的表单：

```shell
   flowId=$(curl -s -X GET \
    -H "Accept: application/json" \
    http://127.0.0.1:4555/self-service/registration/api | jq -r '.id')
curl "http://127.0.0.1:4555/self-service/registration?flow=$flowId" \
    -H 'Accept: application/json' \
    -H 'Content-Type: application/x-www-form-urlencoded' \
    --data-raw 'traits.email=test%40ory.com&traits.name.first=f&traits.name.last=l&password=fVta1Lax&method=password'
```

此时如下表发生了变更：

- identities 生成一条用户记录。
- identity_credentials 生成一条账号记录。
- identity_verifiable_addresses 生成一条邮箱验证记录，处于 pending 状态，发送验证码后切换到 sent 状态。
- identity_recovery_addresses 生成一条邮箱恢复记录。
- identity_credential_identifiers 生成一条账号标识记录。
- selfservice_verification_flows 生成一条邮箱验证流程，有效期是 1 个小时，处于 sent_email 状态。
- identity_verification_codes 生成一条邮箱验证码记录，code 加密存储。
- courier_messages、courier_message_dispatches 生成几条邮箱验证链接发送记录，本测试会发送失败并重试。

接下来我们可以打开 http://127.0.0.1:4436/ 查看邮箱验证的 code，再打开 http://127.0.0.1:4455/welcome 点击 Account Verification 去完成邮箱验证。

此时 identity_verifiable_addresses 表中的记录变成了 completed 状态，表示完成了邮箱验证，用户注册完成。当然没有通过邮箱验证也是可以先登录的，可以在 http://127.0.0.1:4455/welcome 上测试登录。

---

2. 获取登录流程
   flowId=$(curl -s -X GET \
    -H "Accept: application/json" \
    http://127.0.0.1:4555/self-service/login/api | jq -r '.id')
curl -s -X GET \
    -H "Accept: application/json" \
    "http://127.0.0.1:4555/self-service/login/flows?id=$flowId" | jq
   {
   "id": "c8160207-e500-4b71-9219-34d04eb72c14",
   "organization_id": null,
   "type": "api",
   "expires_at": "2024-11-28T06:32:07.630187Z",
   "issued_at": "2024-11-28T06:22:07.630187Z",
   "request_url": "http://kratos:4433/self-service/login/api",
   "ui": {
   "action": "http://127.0.0.1:4433/self-service/login?flow=c8160207-e500-4b71-9219-34d04eb72c14",
   "method": "POST",
   "nodes": [
   {
   "type": "input",
   "group": "default",
   "attributes": {
   "name": "csrf_token",
   "type": "hidden",
   "value": "",
   "required": true,
   "disabled": false,
   "node_type": "input"
   },
   "messages": [],
   "meta": {}
   },
   {
   "type": "input",
   "group": "default",
   "attributes": {
   "name": "identifier",
   "type": "text",
   "value": "",
   "required": true,
   "disabled": false,
   "node_type": "input"
   },
   "messages": [],
   "meta": {
   "label": {
   "id": 1070002,
   "text": "E-Mail",
   "type": "info",
   "context": {
   "title": "E-Mail"
   }
   }
   }
   },
   {
   "type": "input",
   "group": "password",
   "attributes": {
   "name": "password",
   "type": "password",
   "required": true,
   "autocomplete": "current-password",
   "disabled": false,
   "node_type": "input"
   },
   "messages": [],
   "meta": {
   "label": {
   "id": 1070001,
   "text": "Password",
   "type": "info"
   }
   }
   },
   {
   "type": "input",
   "group": "password",
   "attributes": {
   "name": "method",
   "type": "submit",
   "value": "password",
   "disabled": false,
   "node_type": "input"
   },
   "messages": [],
   "meta": {
   "label": {
   "id": 1010022,
   "text": "Sign in with password",
   "type": "info"
   }
   }
   }
   ]
   },
   "created_at": "2024-11-28T06:22:07.63375Z",
   "updated_at": "2024-11-28T06:22:07.63375Z",
   "refresh": false,
   "requested_aal": "aal1",
   "state": "choose_method"
   }
3. 用户登录：模拟用户登录，验证登录认证的正确性。
4. 用户登录
   用户登出
   用户设置
   账号恢复
   邮箱验证
   2FA / MFA
   权限管理
5. 定义角色和权限：在 Keto 中创建角色和权限，测试不同角色对资源的访问控制。
6. 验证权限：尝试访问被保护的资源，验证权限控制的有效性。
   API 保护
7. 配置 OAuth2 客户端：在 Hydra 中注册一个 OAuth2 客户端。
8. 获取访问令牌：使用 OAuth2 流程获取访问令牌，测试 API 访问控制。
   结语
   ORY 全家桶为开发者提供了一套强大且灵活的工具来管理身份认证和访问控制。通过结合 Hydra、Kratos、Keto 和 Oathkeeper，开发者可以轻松地实现复杂的身份管理和安全策略。如果你的应用需要一个可靠的身份管理解决方案，不妨尝试一下 ORY 全家桶。希望这篇文章能帮助你更好地理解和使用 ORY 全家桶，提升应用的安全性和用户体验。
